\documentclass[twocolumn,10pt]{article}
\usepackage[a4paper, top=0.65in, bottom=0.8in, left=0.65in, right=0.65in]{geometry}

\usepackage{graphicx}
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\usepackage{amsmath}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\renewcommand{\algorithmicensure}{\textbf{Output:}}  
\graphicspath{{figure/}}

\begin{document}

\title{\bf Grouper: a Framework for Developing Mobile Applications using Untrusted Servers}

\author{
	Meng Li and Yasushi Shinjo \\
	University of Tsukuba
}

\maketitle

\begin{abstract}

Conventional mobile applications are built based on a client-server mode and require the central servers for storing shared data and processing confidential information.
The users of such mobile applications must fully trust the central servers. 
If the central servers can be accessed by an attacker, a curious administrator, or a government, user information will be revealed because data is often stored on the server in cleartext. 
In addition, users may lose their data when service providers shut down their servers.
This paper presents Grouper, a framework for developing mobile applications, which protects user data by storing data in multiple untrusted servers.
Grouper uses a secret sharing scheme to create several shares from a JSON string of an object and uploads these shares to different untrusted servers. 
Our multiple untrusted servers system is a self-destruction system.
Shares will be deleted after a period of time by the Web service running on the multiple untrusted servers.
To transfer data among mobile devices, we design our own \emph{Grouper Message}. 
We implement Grouper in the Objective-C language at first and evaluate it from developer efforts and performance. We also describe three applications by Grouper framework: an iOS application \emph{Account Book}, a macOS application \emph{Notes} and a benchmark application \emph{Test}.

\end{abstract}

\textbf{Keywords: mobile application security, secret sharing, untrusted server}

\section{Introduction}

Using mobile applications using central trusted servers requires the user to trusted the service provider.
Confidential data stored in a central trusted server will be revealed once a malicious person attacked this server.
Our research goal is to develop light-weight information sharing applications for small groups with our framework Grouper. 
How to protect the sensitive data stored in the central servers is the most important problem in our research.
However, achieving the goal is a great challenge because servers cannot be controlled by users themselves.

To address such a problem, Vanish\cite{geambasu2009vanish}, SafeVanish\cite{zeng2010safevanish}, SeDas\cite{zeng2012sedas} and CouldSky\cite{zeng2015cloudsky} use a data self-destruction system as their cloud storage.
Vanish is a system proposed by Geambasu's research group at the University of Washington. 
Vanish uses Distribute Hash Tables(DHTs) as the back-end storage.
Concretely, to protect a message, Vanish encrypts it with a random encryption key not known to the user, destroys the local copy of the key, and store shares created by a secret sharing scheme of the key in a large, public DHT.
The key in Vanish is permanently after a period of time, and the encrypted message is permanently unreadable.
Vanish is implemented with OpenDHT\cite{rhea2005opendht} or VuzeDHT\cite{vuzedht} which are controlled by a single maintainer. 
Thus, it not strongly secure due to some special P2P oriented attacks\cite{wolchok2010defeating}. 
In addition, the surviving time of the key in Vanish cannot be controlled by user. 

To address such issues in Vanish, Zeng et al. at Huazhong University of Science and Technology, propose SafeVanish and SeDas. 
SafeVanish is designed to prevent hopping attacks by extending the length range of the key shares while SeDas extends the idea of Vanish by exploiting the potentials of active storage networks, instead of the nodes in P2P, to maintain the divided secret key. By extending SeDas, Zeng's group propose CloudSky, a controllable data self-destruction system for untrusted cloud storage. 
In CloudSky, user can control the surviving time of a message.Taking advantage of Attribute Based Encryption (ABE), user can also define the access control policy by themselves.

However, both proposals from Geambasu's group and Zeng's group are not suitable for developing a light-weight information sharing application for following reasons. 
Vanish is suitable for a mail system, because it is designed without needing to modify any of the stored or archived copies of a message and without user controllability, while messages in our target applications should be modified even if it has been sent to multiple untrusted servers.  
Although, CloudSky solves the problems about user controllability in Vanish, the encrypted message are only valuable to the user for a limited period of time.
Our target applications require data usability even user try to synchronize data after the period of time. 
A trusted authority is necessary in CloudSky to manage user profile, while we do not hope any trusted authority in our target application.

Other proposals also use data encryption to protect user data.
DepSky\cite{bessani2013depsky} is a system that stores encrypted data on servers and runs application logic. 
DepSky provides a storage service that improves the availability and confidentiality by using commercial storage services. 
\emph{Cloud-of-Clouds} is the core concept in DepSky. 
It represents that DepSky is a virtual storage, and its users invoke operations in several individual severs. 
DepSky keeps encrypted data in commercial storage services and do application logic in individual servers.
In fact, DepSky is suitable for such data storage applications. 
In Grouper, untrusted servers undertake responsibility of temporarily data storage and message delivery with server-side computation.

Mylar\cite{popa2014building} stores encrypted data on servers, and decrypts this data only in the browsers of users. 
Developers of Mylar use its API to encrypt a regular (non-encrypted) Web application. 
Mylar uses its browser extension to decrypt data on clients. 
Compared to Mylar which is using a single server, Grouper takes advantages of data redundancy provided in the secret sharing scheme.

Sweets\cite{sweets} is a decentralized social networking service (SNS) application using data synchronization with P2P connections among mobile devices. 
Sweets uses Advanced Encryption Standard (AES) to encrypt user data and ABE to encrypt the keys of AES. 
However, there is an obvious problem in such a P2P approach. 
Data transfer can only be finished during two devices are online at the same time. 
Therefore, it is very troublesome for a user of our a target application if nobody is online when he want to synchronize data.
The user can synchronize data from multiple untrusted servers anytime if the application uses the proposal of Grouper.

Inspired by such researches, we proposal our own framework Grouper.
It ensure both data security and usability.
Other advantage of Grouper is data can be recovered even untrusted servers shut down because all devices of group members keep a complete data set of this group.

\section{Assumption and Threat Model}

In this section, we introduce assumptions and threat model of Grouper.

\subsection{Assumption}

There are following basic assumptions underlying the Grouper framework:

\begin{enumerate}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item All group members must trust the group owner and they are not malicious.
	\item In members inviting, a group owner authenticates group members by a face-to-face way.
	\item Nobody has privilege of more than $k$ (the threshold of a secret sharing scheme) untrusted servers.
\end{enumerate}

We consider target users usage scenario of an application by Grouper is a small group like all members in a small office, so all group members of this application are acquaintances and they are not malicious. Due to this reason, their devices can also connect to each other by a face-to-face way.

In Grouper, we use the secret sharing scheme to protect our user data. In a secret sharing scheme, a member securely shares a secret with a group of members by generating $n$ shares using a cryptographic function\cite{smith2013layered}. 
At least $k$ or more shares can reconstruct the secret, but $k-1$ or fewer shares can obtain nothing about the secret\cite{pang2005new}. 
We describe this scheme as a function $f(k, n)$, where $n$ is the number of all shares, and $k$ is the threshold to combine shares. 
Therefore, anyone who has access to $k$ or more shares, he can recover the original data. Although Grouper store shares created by a secret sharing scheme in multiple untrusted servers, these servers are managed by human beings. If one person can access to $k$ or more untrusted servers, he has enough shares to recover the original user data. In fact, we hope each untrusted server's manager does not know the existence of others. For example, the leader of a small company can assign three different employees to deploy the Web service in different servers secretly. This leader must ensure those employees do not collude to crack user data.

\subsection{Threat Model}

There are following key properties of our threat model:

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item \textbf{Server side authentication.}
	Our untrusted servers must perform device authentication. 
	Servers generate access keys for group users. 
	When a device wants to get/put data from/to untrusted servers, the device sends a request with an access key in the request header.
	\item \textbf{Data self-destruction.} 
	Our untrusted servers keep data temporarily.
	We define a period of time in which data can be kept in a server as an interval time. 
	The data in untrusted servers vanishes after the interval time.
	\item \textbf{Secure data transportation.}
	We assume that both inter-mobile device communication during user invitation and HTTP connection between a device and an untrusted server is secure. 
\end{itemize}

Due to the assumptions and key properties of threat model, we can design and implement our Grouper framework.

\section{Design}

In this section, we explain our target applications, basic functions provided by Grouper and advantages in overview (Section 3.1). Then we show the architecture (Section 3.2) of Web service and client of Grouper. At last, we introduce how we design the Grouper framework.

\subsection{Overview}

We are aiming at developing applications which are not relying on trusted central servers.
Concretely, Grouper's design is suitable for applications that:

\begin{enumerate}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item Use in a small groups.
	\item Require light-weight informations sharing among members in a small groups.
	\item Allow face-to-face connection among members' devices.
\end{enumerate}

Grouper support to exchange object among devices.
Binary data can be included in an object, but the isolated binary file is not supported in Grouper.
For example, \emph{Account Book} is an iOS application developed by Grouper. 
In this application, a leader of a small company creates a group and invites employees to the group. 
Then, everyone can record the income and expenditure of this company and share this record to others.
Anyone can edit and delete all records.

To developer such a target application, the Grouper framework should provide the following functions:

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item \textbf{Data Synchronization.} If an user updates an object in his device, the mirrors of this object in other devices are updated.
	\item \textbf{Group management.} A group owner can create a group and invite other members to his group.
\end{itemize}

Compared to pute data self-destruction proposals Vanish, SafeVanish, SeDas and CloudSky, or pure data encryption proposals Mylar and Sweets, Grouper is suitable for developing such light-weight informations sharing applications due to such advantages:

\begin{enumerate}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item User invitation requires a face-to-face way between group owner and new member. It ensures group members are not malicious.
	\item Unlike CouldSky, users are not required to know the approximate lifetime of a message and synchronize it within the lifetime.
	\item Damaged shares from untrusted server do not destroy data synchronization among users completely.
\end{enumerate}

\subsection{Architecture}

\begin{figure}[t]
	\centering
	\includegraphics[scale=0.36]{architecture}
	\caption{Architecture of Grouper.}
\end{figure}

Grouper consists of a Web service (Section 3.1) running on multiple untrusted servers and a client framework (Section 3.2) for developing applications.
Figure 1 describes the architecture of Grouper. 
The clouds represents Web services and the telephones represent the clients.
From clients to the Web service, there are following components:

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item \textbf{Application.}
	The Application by Grouper is installed in the client.
	\item \textbf{Object-Relational Mapping.} 
	Grouper saves data in relational database while access data as the object.
	\item \textbf{Synchronization.}
	Grouper creates a JSON string from an object. Other device synchronize this object by the JSON string. 
	\item \textbf{Secret Sharing.}
	Grouper uses the secret sharing scheme to create several shares from a JSON string and recover the JSON string with the shares.
	\item \textbf{RESTful API.}
	Clients upload shares to untrusted servers and download shares from untrusted server by the RESTful API provided in the Web service.
\end{itemize}

\subsection{Data Synchronization}

We implement data synchronization using the Sync framework\cite{sync} and our own messaging function called \emph{Grouper Message} Protocol.
Using the Sync framework, we get a JSON string from an updated object, send the JSON to other devices, and update the mirrors of the object in these devices. 
We implement \emph{Grouper Message} using untrusted servers and a secret sharing scheme. 
Untrusted servers delete shares after a period of time. 
\emph{Grouper Message} implements reliable messaging over this feature.

\subsubsection{Data Transportation}

Figure 2 describes our data transportation flow using multiple untrusted servers. 
At first, the sender adds an object in his device and Grouper creates three shares by a secret sharing scheme. 
Next, Grouper uploads those shares to three untrusted servers. 
In Figure 2, the receiver is online, and he downloads two shares from two servers and recovers the new record. 
In this process, these servers cannot recover user data because they do not have permission to access other untrusted servers. 

\begin{figure}[t]
	\centering
	\includegraphics[scale=0.36]{sync_flow}
	\caption{Data transportation flow in Grouper.}
\end{figure}

To improve the reliability in data transportation, we design our own scheme $f(k, n, r)$ for Grouper based on the basic the Shamir's secret sharing scheme $f(k, n)$.
In the $f(k, n, r)$ scheme, the parameter $k$ and $n$ is same as which in the  $f(k, n)$ scheme. 
The parameter $r$ represents the number of necessary untrusted servers when a sender uploads shares.
Although the receiver is able to recover the original data from the receiver with more than $k$ shares, we should consider a situation that some shares are broken.
Those broken shares may caused by the unstable network connection, the database damage in untrusted servers or malicious attackers.
Consider the situation that there are $n$ untrusted servers. 
When a sender wants to upload shares to multiple untrusted servers, Grouper will try to upload these shares to all untrusted servers at first.
If the shares are uploaded to $r$ or more untrusted servers, we consider share uploading transaction is successful.
Otherwise, Grouper should try to upload these shares again after a period of time.

\subsubsection{Reliable Synchronization}

Grouper should provide a reliable synchronization service. 
A user in a group creates a new record and all of other members in this group should synchronize this record, even if this record is deleted by untrusted servers after an interval time. 
We call this problem reliable synchronization. 
A receiver can only download shares from untrusted server with the interval time. 
If he is offline within the interval time, he will miss the new record.

\begin{figure}[t]
	\centering
	\includegraphics[scale=0.32]{reliable_sync}
	\caption{Reliable synchronization.}
\end{figure}

To solve this problem, we use the idea of reliable multicasting in distribute systems. 
In Figure 2, the sender has sent messages from No.1 to No.4. 
Next, he sends sequence numbers of all messages he sent to the receiver. 
When the receiver receives the sequence numbers, he checks his local persistent store. 
In this situation, the receiver finds that he missed the message No.3 and No.4. 
Thus, he will send a resend request that contains the sequence numbers of messages he missed to the sender. 
At last, the sender will send the message No.3 and No.4 again to the receiver again.

\subsubsection{Grouper Message Protocol}

To transfer data between devices, we design our own protocol, \emph{Grouper Message} Protocol. 
In this protocol, a message is a JSON string that contains an object of an application and the way to handle it in receiversâ€™ devices. 
There are 4 types of Grouper messages: update message, delete message, confirm message and resend message. 
Both update message and delete message need resending because they contain the objects of an application. 
We call these messages normal messages. 
Both confirm message and resend message contain control information about reliable multicast and need not resending. 
We call these messages control messages.

When a user creates a new object or modifies some attributes of an existing object, the device sends an update message that contains the JSON string of this object to all group members.

When a user deletes an existing object, the device sends a delete message that contains the object ID of this object to all group members.

To confirm all devices have received all normal messages (update message and delete message) created by a user, the device sends a confirm message to all devices periodically. 
In this confirm message, the sequence number of objects recently created in this device are included.

When the device of a group member receives a confirm message, it checks the sequence numbers. 
If some of them do not exist in the persistent store, the device sends a resend message that contains missing sequence numbers.

\subsection{Group Management}

\subsubsection{Creating a Group}

A user creates a group, and he becomes the owner of this group.  
Before creating a group, the owner prepares his own user information including his email and name, multiple untrusted servers, a group ID and a group name. 
Next, he initializes this group on all untrusted server by submitting his node identifier. 
The node identifier, which represents his device, is generated by Grouper randomly when the application is launched at the first time. 
In each untrusted server, the Web service initializes this new group and returns a master key including the highest privilege to the owner. 
The owner can add other members to an untrusted server by the master key.

\subsubsection{Inviting a Member}

After creating a group, the owner can invite a new member to his group. 
To join the group, the new member prepares his user information at first. 
The owner invites the new member by a face-to-face way rather than using central servers. 
Before inviting, Grouper establishes connection between their devices using local secure links like \emph{Multipeer Connectivity}\cite{mc}. 
Firstly, the new member sends user information and a node identifier to the owner. 
Owner saves the user information and the node identifier of the new member to his device. 
Secondly, the owner registers the new member on multiple untrusted servers by submitting the node identifier of the new member. 
Thirdly, untrusted servers returns access keys for the new member to the owner. 
Lastly, the owner sends the access keys, server addresses and the list of existing members to the new member. 
After receiving them, the new member can access these untrusted servers with the keys.

\section{Implementation}

We introduce the implementation of the Web service (Section 3.1), the implementation of the client framework (Section 3.2) and demo applications (Section 4.3) in this section.

\subsection{Web Service}

Grouper needs its own Web service rather than using commercial general cloud services like Amazon S3, Google Cloud for the following reasons:

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item The Web service must provide reliable synchronization based on the \emph{Grouper Message} protocol.
	\item The Web service must ensure that shares are deleted after a prescriptive time.
\end{itemize}

Our Web service provides RESTful API to transfer data with clients. 
It runs on the Tomcat server that is an open source implementation of the Java Servlet, JavaServer Pages, Java Expression Language and Java WebSocket technologies. 
We use the Spring MVC, a  Web model-view-controller framework, to create our RESTful API, and Hibernate, an open source Java Object-Relational Mapping (ORM) framework, to save and operate objects in the Web service. 

Our Web service includes three kinds of entities. 
They are \emph{Group}, \emph{User} and \emph{Transfer} entities. 
A \emph{Group} entity saves a group ID, a group name and its owner. 
A \emph{User} entity saves the node identifier of a user, the access key for this user, and the group entity of this user. 
A \emph{Transfer} entity saves a share generated with a secret sharing scheme, the time when the user uploads the share. 
For each user, there is a unique access key for him in an untrusted server. For a group, one of a user is its owner who has the highest privilege of this group.

\subsection{Client}

Grouper's client framework is developed in Objective-C, and it supports developing applications on iOS, macOS, watchOS and tvOS.
It is based on the following frameworks.   

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item 
	\emph{Multipeer Connectivity}\cite{mc},  an official Peer-to-Peer communication framework provided by Apple. 
	Grouper uses it to transfer data between two devices by a face-to-face way.
	\item 
	\emph{Core Data}\cite{coredata}, an official ORM framework provided by Apple.
	\emph{Core Data} provides generalized and automated solutions to common tasks associated with object life cycles and object graph management, including persistence. 
	Grouper uses it to manage model layer objects. 
	\item 
	\emph{Sync}\cite{sync}, a synchronization framework for \emph{Core Data} using JSON. 
	When a user sends messages, Grouper uses it to create JSON strings from objects. 
	When an other user receives messages, Grouper uses it to parse JSON strings and synchronize the recovered objects into \emph{Core Data}.
	\item 
	\emph{c-SSS}\cite{c-sss}, an implementation of the secret sharing scheme.
	\item 
	\emph{AFNetworking}\cite{afnetworking}, a delightful networking library in Objective-C. 
	Grouper uses it to invoke the RESTful API provided by our Web services running on multiple untrusted servers. 
\end{itemize}

\subsection{Applications}

Using Grouper framework, we are developing the following applications. 

\begin{itemize}
	\setlength{\itemsep}{1pt}
	\setlength{\parskip}{0pt}
	\setlength{\parsep}{0pt}
	\item \emph{Account Book}, an iOS application in Objective-C, records the income and expenditure of a group.
	\item \emph{Test}, a benchmark iOS aapplication in Swift, tests the performance of Grouper.
	\item \emph{Notes}, a macOS application in Swift, takes shared notes for a small group.
\end{itemize}

\section{Evaluation}

This section shows the developer efforts to use Grouper and the performance of Grouper.

\subsection{Developer Efforts}

We see developer efforts through two factors: the usability of the client API and the code size in the lines of code(LoC) the developer has to add after using Grouper. 
Grouper provides the following simple client API for developers.

\begin{table*}[t]
	\centering
	\caption{Client APIs of Grouper}
	\label{my-label}
	\begin{tabular}{ll}
		\hline
		\textbf{Methods} & \textbf{Semantics} \\ \hline
		grouper.\textbf{setup}(appId, dataStack) & 
		\begin{tabular}{@{}l@{}}
			Setup Grouper with appId and dataStack. AppId of an application must be \\ 
			unique. Datastack can be created by invoking the API provided in the Sync \\
			framework.
		\end{tabular}  \\ \hline
		grouper.sender.\textbf{update}(object) & 
		\begin{tabular}{@{}l@{}}
			Invoke this method after creating a new object or modifying an existing object. \\
			Developers must ensure  this object has been saved to persistent store before\\
			invoking update method.
		\end{tabular} \\ \hline
		grouper.sender.\textbf{delete}(object) & 
		\begin{tabular}{@{}l@{}}
			Invoke this method when a user wants to delete an existing object. Developers \\
			need not to delete the object and save to persistent store before invoking delete \\ 
			method. Once you delete it, Grouper cannot create Grouper message from this \\ 
			object. Grouper will delete the object and save it to persistent store automatically \\
			after finishing message transportation.
		\end{tabular} \\ \hline
		grouper.receiver.\textbf{receive}(callback) & 
		\begin{tabular}{@{}l@{}}
			Invoke this method if a user wants to synchronize data from untrusted servers.\\
			Callback functions is provided for executing UI updating code.
		\end{tabular} \\ \hline
		grouper.sender.\textbf{confirm}() & 
		\begin{tabular}{@{}l@{}}
			Invoke this method to send confirm message to other group members. \\
		\end{tabular} \\ \hline
	\end{tabular}
\end{table*}

We have developed two applications including \emph{Account Book} and \emph{Test} with Grouper. 
As described in Table 1, based on the stand alone application without data synchronization, developers can add data synchronization to these applications with Grouper by adding a small number of code. 

\begin{table}[!htb]
	\footnotesize
	\centering  
	\caption{Applications' lines of code}
	\begin{tabular}{c|c|c}
		\hline
		Application Name           & Test  & Account Book \\ \hline
		Platform            & iOS   & iOS          \\ \hline
		Lanaguage           & Swift & Objective-C  \\ \hline
		Number of Entities  & \multicolumn{1}{r|}{1}     & \multicolumn{1}{r}{5}            \\ \hline
		Stand Alone Application LoC     & \multicolumn{1}{r|}{621}   & \multicolumn{1}{r}{8760}         \\ \hline
		Application with Groper LoC     &  \multicolumn{1}{r|}{632}   & \multicolumn{1}{r}{8950}         \\ \hline
		Increased LoC & \multicolumn{1}{r|}{11}    & \multicolumn{1}{r}{190}           \\ \hline
	\end{tabular}
\end{table}

\subsection{Performance}

The performance goal is to avoid significantly affecting the user experience with the application developed with Grouper. 
To evaluate whether Grouper meets this goal, we use the benchmark application \emph{Test} with the $f(2, 3)$ secret sharing scheme to transfer data between iPhone 4s and iPod 5 generation on a wireless LAN network (802.11n). 
Both iPhone 4s and iPod 5 generation have A5 CPU and 512MB of RAM.

\begin{figure}[t]
	\centering
	\includegraphics[scale=0.12]{processing1}
	\caption{Sending and receiving a single message.}
\end{figure}

\begin{figure}[t]
	\centering
	\includegraphics[scale=0.12]{processing2}
	\caption{Sending multiple messages.}
\end{figure}

First, we measured processing times the benchmark application \emph{Test} needed when a user created a test object during online. 
We used iPhone 4s to create an object and send a update message. 
We used iPod 5 generation to receive the update message from iPhone 4s.
Figure 4 shows the processing time for sending and receiving a single message after creating this object.
This size of the message was 620 bytes.
Compared to the network time, data sync and secret sharing consumed very little time in both data sending and receiving.

Next, we measured processing times \emph{Test} needed when a device sent update messages to untrusted servers.
We used iPod 4s to create multiple objects and to send multiple update messages at the same time.
Figure 5 shows the processing time for sending multiple messages. 
As the number of messages increased, data sync and secret sharing part increased linearly. 
The network part increased very slowly and sometimes decreased.

These experimental results show that data synchronization within a hundred messages does not influence the user experience. A group of an application by Grouper is able to expand to 100 members. 

\section{Related Work}



\section{Conclusion and Future Work}

This paper describes Grouper, a framework using a secret sharing scheme and multiple untrusted servers, to develop mobile applications.
Grouper provides two main functions: reliable data synchronization and group management. 
We implement Grouper's Web service in Java EE and clients in Objective-C. 
We use Grouper to develop applications including \emph{Account Book}, \emph{Notes} and \emph{Test}. 
We evaluate Grouper from developer efforts and performance. 

In the future, we will finish the application \emph{Notes} on macOS, solve the problems of synchronization order and JSON string redundancy caused by One-To-Many entity relationship, and improve the performance.

\bibliographystyle{unsrt}
{
	\footnotesize
	\bibliography{ref}
}

\end{document}
